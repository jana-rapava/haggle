#################
#
# LLOYD15
#
#################
 nextstep1: implementuj Matrix ako Expandable
 nextstep1.1: otestuj a odlad BeFS a BFS
 nextstep1.2: skus spojit, implementuj >>= pre nasu monadu
 nextstep1.4: ukladat backlog do leftist haldy (module heaps)
 nextstep2: implement search algorithms
 BFS
 best-first search (should we be able to come back and expand completely different node if it's better than any child of current node? how for goodness sake am I supposed to implement that? asi ukladat uzly aj s hodnotou heuristiky a pamatat si najlepsiu heuristiku v backlogu - prvy uzol s touto hodnotu, ktory najdem, expandujem)
 iterative deepening
 limited discrepancy search
 SMA*
  - be able to select list from backlog, edit it, and put it back
  - be able to get worst node stored in backlog
 Monte Carlo Tree Search (basically write a very special heuristic function)
nextstep5: ako sa aplikuje nextBoards na backlog? sprava sa to ako monada/applicative?
 existuje operator pre skladanie funkcii, ktory dostane f,g,h a x a zavola f (g x) (h x)?
 this is composition operator for 2 unary functions
c2 :: (a -> b) -> (a -> c) -> (b -> c -> d) -> a -> d
c2 f g1 g2 x = f (g x) (h x)
 pointfreed: flip . (ap .) . flip (.)
 ?use array for matrices and adjacent
 use something which can be reorganized and pruned fast for paths (can I get better complexity than nlog n when I need only delete and lookup? I can built optimal search tree for a given set and then mark entries as deleted; so 'lookup, then delete' will be O(log n), but now I have problem with stopping condition
 * each node has two extra fields: deleted and marked
 * when searching for data:
      * root is marked -> tree is empty, end
      * I find them in a marked node -> delete, check its sibling, mark parent if appropriate
      * I find them in an unmarked node -> delete
 use something with stack operations which saves memory for backlog
 use lenses instead of lists (probably would not pay off)

#################
#
# TSP
#
################
nextstep: po oprave DFS/BeFS implementuj tuto funkciu pre TSP
